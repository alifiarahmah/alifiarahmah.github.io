{"pageProps":{"post":{"title":"Intermediate React, v4 - Notes","date":"2020-08-11","slug":"intermediate-react-v4-notes","content":"\r\nThis is the note I take as I watch this course \r\n[Intermediate React, v4 | FrontendMasters](https://frontendmasters.com/courses/intermediate-react-v4/)\r\n\r\n## Hooks in Depth\r\n\r\n### `useState`\r\n\r\nLets you manage state of React component.\r\n\r\n### `useEffect`\r\n\r\nLets you call side effect for component outside of normal render cycle. Second argument is used to determine dependencies. \r\n\r\n### `useContext`\r\n\r\nIf not using useContext, we have to pass context to component several levels lower way down (prop drilling). We can access/update context from child level. Using useContext solve this problem like a global variable, but it don't show the explicit relationship between components.\r\n\r\n### `useRef`\r\n\r\nuseRef difference from useState is that it's a reference to the DOM element. useState will be changed when component re-renders, but useRef will be changed when component unmounts.\r\n\r\n### `useReducer`\r\n\r\nBasically useState with extra steps to manage state using dispatch, break it and make it testable. Using the reducer with the same state and action will always return the same new state.\r\n\r\n### `useMemo`\r\n\r\nuseMemo is a function that memoizes a function or value. It's useful when you want to memoize a function that is expensive to compute or when you want to memoize a value that you expect to be constant (no need to recalculate).\r\n\r\n### `useCallback`\r\n\r\nSame as useMemo, useCallback is used for performance optimization. It's a function that memoizes a function and only recalculates if the dependencies change.\r\n\r\n### `useLayoutEffect`\r\n\r\nSame as useEffect, but it's called after the component has been mounted. It's synchronous to render. This is helpful because useLayout runs the same time as `componentDidMount` and `componentDidUpdaete` in class component, where `useEffect` is scheduled after. Use `useLayoutEffect` if it is guaranteed that the effect will run synchronously after the component has been mounted.\r\n\r\n### `useImperativeHandle`\r\n\r\nuseImperativeHandle is a function that lets you customize methods of object that is returned from useRef hook.  It's useful when you want to pass a ref to a component that is not a child of the component you are using it in, expecially on creating libraries.\r\n\r\n### `useDebugValue` & `useId`\r\n\r\nuseDebugValue can be used to expose custom value while debugging custom hooks in DevTools. useId is a function that generate a unique ID.\r\n\r\n## TailwindCSS\r\n\r\n### CSS & React\r\n\r\nTailwind is not tied to React. It's a CSS framework.\r\n\r\nInstall:\r\n```\r\nnpm i -D tailwindcss@3.0.22 postcss@8.4.6 autoprefixer@10.4.2\r\n```\r\n\r\nInit Tailwind project:\r\n```\r\nnpx tailwindcss init\r\n```\r\n\r\nThis will create a tailwind config in `tailwind.config.js`.\r\n\r\nThen add these line in the beginning of the global CSS file\r\n\r\n```css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\nThen create `.postcssrc` in root directory\r\n\r\n```json\r\n{\r\n  \"plugins\": {\r\n    \"autoprefixer\": {},\r\n    \"tailwindcss\": {}\r\n  }\r\n}\r\n```\r\n\r\n### Basics & Gradients\r\n\r\nBasically, working with Tailwind CSS require us to implement CSS rules via adding `className` to our component so component will have a long className string from Tailwind. But sometimes we will have to add some custom style e.g. background image because Tailwind doesn't support it.\r\n\r\n```jsx\r\n<div\r\n\tclassName=\"p-0 m-0\"\r\n\tstyle={{\r\n\t\tbackground: \"url(http://pets-images.dev-apis.com/pets/wallpaperA.jpg)\",\r\n\t}}\r\n>\r\n  \t...\r\n</div>\r\n```\r\n\r\nMore Tailwind CSS class can be found at the docs.\r\n\r\n### CSS Libraries\r\n\r\nUsing Tailwind will make our CSS size much smaller. There are several other tools to do styling, including emotion and styled-components. They are good if we need to have some javascript functionality in our CSS like computing colors, etc.\r\n\r\n### Layout Basics\r\n\r\nWe can also use Tailwind to layout our components using flex.\r\n\r\n### Tailwind Plugins\r\n\r\nThere are several component styling by Tailwind CSS. Install it with\r\n\r\n```\r\nnpm install -D @tailwindcss/forms@0.4.0.\r\n```\r\n\r\nThis will apply some default styling to basic form elements. In text input, add `type=text` so it will be styled as a text input.\r\n\r\n### Grid & Breakpoints\r\n\r\nWe can also use Tailwind to layout our components using grid and it's much easier than using pure CSS. We can also make it responsive.\r\n\r\n### Positioning\r\n\r\nWe can also have relative positioning in CSS.\r\n\r\n## Code Splitting & Server Side Rendering\r\n\r\n### Code Splitting\r\n\r\nCode splitting is a technique to split our application into smaller parts so the application won't be loaded all at once. This is useful when we have a big application and we want to load it faster. To implement this, we can use `Suspense` and `React.lazy` in router.\r\n\r\n```jsx\r\nimport { useState, StrictMode, lazy, Suspense } from \"react\";\r\n\r\nconst Details = lazy(() => import(\"./Details\"));\r\nconst SearchParams = lazy(() => import(\"./SearchParams\"));\r\n\r\nconst App = () => {\r\n\treturn (\r\n\t\t<Suspense fallback={<h1>loading route...</h1>}>\r\n\t\t\t<BrowserRouter>\r\n\t\t\t\t...\r\n\t\t\t</BrowserRouter>\r\n\t\t</Suspense>\r\n\t);\r\n}\r\n```\r\n\r\nOther than this, the code can be load asynchronously with `lazy`.\r\n\r\n```jsx\r\nimport { ..., lazy } from \"react\";\r\n\r\nconst Modal = lazy(() => import(\"./Modal\"));\r\n```\r\n\r\n### Server Side Rendering\r\n\r\nPerformance is a big concern when we have a big application. There are several ways to improve performance. One challenge is to load the correct content first so user can see the site faster.\r\n\r\nServer side rendering is a technique to run React on the server before send it to the user and send the first rendering of the application. The user will only has to download the HTML and see the page, otherwise the user has to download HTML, JS, and load it before showing anything. The total time is relative slower because the React app is loading in the background, but the time the user see something on the page is much faster.\r\n\r\nTo implement SSR, we have o change where our app is rendered. We use `hydrate` from `react-dom` instead of `render`, and then achieve it using Express and Node.\r\n\r\n### Streaming Markup\r\n\r\nWe can use *streaming* when making HTTP request so we can send response in chunks (partially rendered) instead of sending the whole big payload at the end. Browser can immediately start downloading CSS while the app is loading. To implement this, we can use `renderToNodeStream` from `react-dom/server`.\r\n\r\n## TypeScript\r\n\r\nTypescript make you write javascript code in a more strict way. It's a good way to make sure your team don't make mistakes as the project scales up. TypeScript make the code more readable and maintainable.\r\n\r\n### Setup & Refactoring\r\n\r\nInstall\r\n\r\n```\r\nnpm install -D typescript@4.5.5\r\n```\r\n\r\nThen run\r\n```\r\nnpx tsc --init\r\n```\r\n\r\nIt will generate `tsconfig.json` file. Some React dependency types are required to be installed.\r\n\r\n```\r\nnpm install -D @types/react@17.0.39 @types/react-dom@17.0.11\r\n```\r\n\r\n### TypeScript & ESLint\r\n\r\nThere is a project called `typescript-eslint` to replace TSLint (deprecated) that can be used to lint TypeScript code using ESLint.\r\n\r\n```\r\nnpm install -D eslint-import-resolver-typescript@2.5.0 @typescript-eslint/eslint-plugin@5.13.0 @typescript-eslint/parser@5.13.0\r\n```\r\n\r\nChange `package.json` \"lint\" entry to \r\n```json\r\n\"scrips\": {\r\n\t...\r\n\t\"lint\": \"eslint \\\"src/**/*.{js,jsx,ts,tsx}\\\" --quiet\",\r\n\t...\r\n}\r\n```\r\n\r\nModify `.eslintrc.json`\r\n\r\n```json\r\n{\r\n\t\"extends\": [\r\n\t\t...,\r\n\t\t\"plugin:@typescript-eslint/recommended\",\r\n\t\t\"plugin:@typescript-eslint/recommended-requiring-type-checking\",\r\n\t\t\"prettier\"\r\n\t],\r\n\t\"rules\": {\r\n\t\t...,\r\n\t\t\"@typescript-eslint/no-empty-function\": 0\r\n\t},\r\n\t\"plugins\": [..., \"@typescript-eslint\"],\r\n\t\"parserOptions\": {\r\n\t\t...,\r\n\t\t\"project\": [\"./tsconfig.json\"],\r\n\t\t...\r\n\t}\r\n\t...,\r\n\t\"settings\": {\r\n\t\t...,\r\n\t\t\"import/parsers\": {\r\n\t\t\t\"@typescript-eslint/parser\": [\".ts\", \".tsx\"]\r\n\t\t},\r\n\t\t\"import/resolver\": {\r\n\t\t\t\"typescript\": {\r\n\t\t\t\t\"alwaysTryTypes\": true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### TypeScript Basic Notes\r\n\r\n1. We can have a strict ordering of string and function which will be enforced to make other file easier to type.\r\n\r\n2. `interface` is a way to define a object-like type that can be used in other file. Use interfaces unless you need type aliases.\r\n\r\n\t```ts\r\n\t// by export it, we can use it in other file\r\n\texport interface Pet {\r\n\t\tid: number;\r\n\t\tname: string;\r\n\t\t...\r\n\t}\r\n\r\n\texport interface PetAPIResponse {\r\n\t\tnumberOfResults: number;\r\n\t\t...\r\n\t}\r\n\t```\r\n\r\n3. We can make a custom, more-strict type alias that just allows a few different values by declare it with `type`.\r\n\r\n\t```ts\r\n\texport type Animal = \"dog\" | \"cat\";\r\n\t```\r\n\r\n4. The type of a value can be enforced with `... as ...` syntax.\r\n\r\n5. If the param can be undefined, we can use `?` to make it optional.\r\n\r\nAdd type check to `package.json`\r\n\r\n```\r\n\"scripts\": {\r\n\t...,\r\n\t\"typecheck\": \"tsc --noEmit\",\r\n\t...\r\n}\r\n```\r\n\r\n## Redux\r\n\r\nRedux is a library that does state management. Back then, Redux was made to replace Context that used to be worse in React. One feature of Redux is that it is testable.\r\n\r\nInstall Redux\r\n\r\n```\r\nnpm install redux@4.1.2 react-redux@7.2.6\r\n```\r\n\r\nIncluding Redux middleware\r\n```js\r\nimport { createStore } from \"redux\";\r\nimport reducer from \"./reducers\";\r\n\r\nconst store = createStore(\r\n\treducer,\r\n\ttypeof window === \"object\" &&\r\n\t\ttypeof window.__REDUX_DEVTOOLS_EXTENSION__ !== \"undefined\"\r\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION__()\r\n\t\t: (f) => f\r\n);\r\n\r\nexport default store;\r\n```\r\n### Reducers\r\n\r\ncombineReducers is a function that takes an object of reducers and returns a reducer function.\r\n\r\n```js\r\nimport { combineReducers } from \"redux\";\r\nimport location from \"./location\";\r\n\r\nexport default combineReducers({\r\n  location,\r\n  ...\r\n});\r\n```\r\n\r\nReducer takes an old state, an action, and combines those things to make a state. A reducer must have a default state. Reducer are synchronous.\r\n\r\n```js\r\nexport default function location(state = \"Seattle, WA\", action) {\r\n  switch (action.type) {\r\n    case \"CHANGE_LOCATION\":\r\n      return action.payload;\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n\r\n### Action Creators\r\n\r\nAction Creators are functions that return action objects.\r\n\r\n```js\r\nexport default function changeTheme(theme) {\r\n  return { type: \"CHANGE_THEME\", payload: theme };\r\n}\r\n```\r\n\r\n### Providers & Dispatching Actions\r\n\r\nProvider is a component that wraps the app and provides the store to the app.\r\n\r\n```jsx\r\nimport { Provider } from \"react-redux\";\r\nimport store from \"./store\";\r\n\r\nconst App = () => {\r\n\treturn (\r\n\t\t<Provider store={store}>\r\n\t\t\t<App />\r\n\t\t</Provider>\r\n\t);\r\n}\r\n```\r\n\r\nNow we can use Redux in component.\r\n\r\n```jsx\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport changeLocation from \"./actionCreators/changeLocation\";\r\n...\r\n\r\nconst location = useSelector((state) => state.location);\r\n...\r\nconst dispatch = useDispatch();\r\n\r\nconst SearchParams = () => {\r\n\treturn (\r\n\t\t...\r\n\t\t<input\r\n\t\t\tid=\"location\"\r\n\t\t\tvalue={location}\r\n\t\t\tplaceholder=\"Location\"\r\n\t\t\tonChange={(e) => dispatch(changeLocation(e.target.value))}\r\n\t\t/>\r\n\t\t...\r\n\t)\r\n}\r\n```\r\n\r\n\r\n### Redux Dev Tools\r\n\r\nRedux Dev Tools is a browser extension that allows us to see the state of the store.\r\n\r\n## Testing\r\n\r\nJest is a testing library that allows us to write tests in JavaScript. It is built on top of Jasmine.\r\n\r\nInstall Jest\r\n```\r\nnpm install -D jest@27.5.1 @testing-library/react@12.1.3\r\n```\r\n\r\nReplace `.babelrc` with\r\n```json\r\n{\r\n  \"presets\": [\r\n    [\r\n      \"@babel/preset-react\",\r\n      {\r\n        \"runtime\": \"automatic\"\r\n      }\r\n    ],\r\n    \"@babel/preset-env\"\r\n  ],\r\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"],\r\n  \"env\": {\r\n    \"test\": {\r\n      \"presets\": [\r\n        [\r\n          \"@babel/preset-env\",\r\n          {\r\n            \"targets\": {\r\n              \"node\": \"current\"\r\n            }\r\n          }\r\n        ]\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAdd `test` script to `package.json`\r\n```json\r\n\"scripts\": {\r\n\t...,\r\n\t\"test\": \"jest\",\r\n\t\"test:watch\": \"jest --watch\"\r\n\t...\r\n}\r\n```\r\n\r\n### Basic React Testing\r\n\r\n- Try to test functionality, not implementation\r\n- Don't test UI or something that likely to change, test the action to the UI instead\r\n- Test the important part to the user\r\n- Delete test on a regular basis\r\n- Fix/delete bad test\r\n\r\nBasic test file has extension `.test.js` or `.spec.js`\r\n\r\n```js\r\nimport { expect, test } from \"@jest/globals\";\r\nimport { render } from \"@testing-library/react\";\r\nimport Pet from \"../Pet.js\"; // the component\r\n\r\ntest(\"displays a default thumbnail\", async () => { // test case\r\n  const pet = render(<Pet />);\r\n\r\n  const petThumbnail = await pet.findByTestId(\"thumbnail\");\r\n  expect(petThumbnail.src).toContain(\"none.jpg\");\r\n});\r\n```\r\n\r\n`findByTestId` is a function that finds a component by its test id. To catch a specific component for testing, we can add a `data-testid` attribute to the component.\r\n\r\nFor testing custom hooks, we can make a fake component, or using `@testing-library/react-hooks`, then we can use `renderHook` to render a component.\r\n\r\n### Mocks\r\n\r\nTo test a component that uses a library that is not available in the browser, we can mock the library. A mock is a fake implementation.\r\n\r\nInstall\r\n\r\n```\r\nnpm install -D jest-fetch-mock@3.0.3\r\n```\r\n\r\nAdd to `package.json`\r\n\r\n```json\r\n{\r\n  \"jest\": {\r\n    \"automock\": false,\r\n    \"setupFiles\": [\"./src/setupJest.js\"]\r\n  }\r\n}\r\n```\r\n\r\nCreate `setupJest.js` in root.\r\n\r\n```js\r\nimport { enableFetchMocks } from \"jest-fetch-mock\";\r\n\r\nenableFetchMocks();\r\n```\r\n\r\nImplement in testing\r\n\r\n```js\r\ntest(\"...\", async () => {\r\n\tconst breeds = [\r\n\t\t...\r\n\t];\r\n\tfetch.mockResponseOnce(\r\n\t\tJSON.stringify({\r\n\t\tanimal: \"...\",\r\n\t\tbreeds,\r\n\t\t})\r\n\t);\r\n\tconst { result, waitForNextUpdate } = renderHook(() => useBreedList(\"dog\"));\r\n\tawait waitForNextUpdate();\r\n\t...\r\n});\r\n```\r\n\r\n### Snapshots\r\n\r\nSnapshot tests are a low-cost way to write tests.\r\n\r\n```\r\nnpm install -D react-test-renderer@17.0.2.\r\n```\r\n\r\nAdd\r\n```js\r\n/**\r\n * @jest-environment jsdom\r\n */\r\n\r\nimport { expect, test } from \"@jest/globals\";\r\nimport { create } from \"react-test-renderer\";\r\nimport Results from \"../Results\";\r\n\r\ntest(\"renders correctly with no pets\", () => {\r\n  const tree = create(<Results pets={[]} />).toJSON();\r\n  expect(tree).toMatchSnapshot();\r\n});\r\n```\r\n\r\nThe snapshot will show on the CLI and create a `__snapshots__` folder.\r\n\r\n### Test Coverage with Istanbul\r\n\r\nAdd command to `package.json`\r\n\r\n```json\r\n\"scripts\": {\r\n\t...,\r\n\t\"test:coverage\": \"jest --coverage\"\r\n\t...\r\n}\r\n```\r\n\r\nThe script will generate a report of things that are covered and not coveredd with tests. It will also generate a `index.html` file open in the browser by running\r\n```\r\nopen coverage/lcov-report/index.html\r\n```\r\n\r\nAdd `coverage` to `.gitignore`"}},"__N_SSG":true}