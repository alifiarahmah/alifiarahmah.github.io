{"pageProps":{"post":{"title":"Complete Intro to React, v7 - Notes","date":"2020-08-06","slug":"complete-intro-to-react-v7-notes","content":"\r\nThis is the note I take as I watch this course \r\n[Complete Intro to React, v7 - FrontendMasters](https://frontendmasters.com/courses/complete-react-v7/)\r\n## Vanilla React\r\n\r\nReact can be used purely by importing the react script in HTML.\r\n\r\n````HTML\r\n<body>\r\n  <div id=\"root\">not rendered</div>\r\n  <script src=\"https://unpkg.com/react@17.0.2/umd/react.development.js\"></script>\r\n  <script src=\"https://unpkg.com/react-dom@17.0.2/umd/react-dom.development.js\"></script>\r\n  <script>\r\n    // Your code is going to go here\r\n  </script>\r\n</body>\r\n````\r\n\r\nThen we put our code in the last script tag.\r\n\r\n```js\r\nconst App = () => {\r\n  return React.createElement(\r\n    \"div\",\r\n    {},\r\n    React.createElement(\"h1\", {}, \"Adopt Me!\")\r\n  );\r\n};\r\n\r\nReactDOM.render(React.createElement(App), document.getElementById(\"root\"));\r\n```\r\n\r\nTo implement best practice, we could separate the code into a separate file called `App.js` then import it in the HTML file with `<script src=\"App.js\"></script>`.\r\n\r\n### Component\r\n\r\nCreate component that return element with multiple children with passing it in array of elements. \r\n```js\r\nconst Pet = () => {\r\n  return React.createElement(\"div\", {}, [\r\n    React.createElement(\"h1\", {}, \"Luna\"),\r\n    React.createElement(\"h2\", {}, \"Dog\"),\r\n    React.createElement(\"h2\", {}, \"Havanese\"),\r\n  ]);\r\n};\r\n```\r\n\r\nThe component will be used inside the `App` component.\r\n```jsx\r\nconst App = () => {\r\n  return React.createElement(\r\n    \"div\",\r\n    {},\r\n    React.createElement(\"h1\", {}, \"Adopt Me!\"),\r\n    ...\r\n    React.createElement(Pet)\r\n  );\r\n}\r\n```\r\n\r\nAdd props to the element\r\n```jsx\r\nconst Pet = (props) => {\r\n  return React.createElement(\"div\", {}, [\r\n    React.createElement(\"h1\", {}, props.name),\r\n    React.createElement(\"h2\", {}, props.animal),\r\n    React.createElement(\"h2\", {}, props.breed),\r\n  ]);\r\n};\r\n\r\nconst App = () => {\r\n    return React.createElement(\"div\", {}, [\r\n      React.createElement(\"h1\", {}, \"Adopt Me!\"),\r\n      ...\r\n      React.createElement(Pet, {\r\n        name: \"Luna\",\r\n        animal: \"Dog\",\r\n        breed: \"Havanese\"\r\n      })\r\n    ]);\r\n}\r\n```\r\n\r\n## JS Tools\r\n\r\n### npm (Node Package Manager)\r\n\r\nBring various open source code modules to import into the project.\r\n\r\nTo initialize, run\r\n```sh\r\nnpm init -y\r\n```\r\nIt will make a new file called `package.json` in the root directory.\r\n\r\n### Prettier\r\n\r\nRe-print the code with a predefined style. This is a good way to make sure the code is formatted correctly.\r\n\r\nTo install prettier globally, run\r\n```sh\r\nnpm install --global prettier\r\n```\r\n\r\nTo declare a project as a prettier project, create a file `.prettierrc`. This configuration could be either empty (only contains `{}`) or have some configuration.\r\n\r\nTo manually format the code, run\r\n```sh\r\nprettier --write \\\"src/**/*.{js,jsx}\\\"\r\n```\r\n\r\nWe can also set up a CLI command in the `package.json` to format the code automatically.\r\n\r\n```json\r\n\"scripts\": {\r\n  \"format\": \"prettier --write \\\"src/**/*.{js,jsx}\\\"\"\r\n}\r\n```\r\n\r\nThen we can use `npm run format` to format the code.\r\n\r\n### ESLint\r\n\r\nIt is a linter to enforce a style guide for JavaScript code.\r\n\r\nTo install ESLint, run\r\n```sh\r\nnpm install -D eslint@8.8.0 eslint-config-prettier@8.3.0\r\n```\r\n\r\nThere are so many preset configs. To create a new config, create a file `.eslintrc.json`.\r\n\r\n```json\r\n{\r\n  \"extends\": [\"eslint:recommended\", \"prettier\"],\r\n  \"plugins\": [],\r\n  \"parserOptions\": {\r\n    \"ecmaVersion\": 2022,\r\n    \"sourceType\": \"module\",\r\n    \"ecmaFeatures\": {\r\n      \"jsx\": true\r\n    }\r\n  },\r\n  \"env\": {\r\n    \"es6\": true,\r\n    \"browser\": true,\r\n    \"node\": true\r\n  }\r\n}\r\n```\r\n\r\nTo run ESLint, add the CLI command to `\"scripts\"`.\r\n```sh\r\n\"lint\": \"eslint \\\"src/**/*.{js,jsx}\\\" --quiet\",\r\n```\r\n\r\n### Git\r\n\r\nThere are several things that shouldn't we commit to repo. Add to `.gitignore`\r\n\r\n- `node_modules`\r\n- `.parcel-cache/`\r\n- `dist/`\r\n- `.env`\r\n- `.DS_Store`\r\n- `coverage/`\r\n- `.vscode/`\r\n\r\n### Parcel\r\n\r\nA bundler for modern JavaScript applications. It crawl through the project and bundle all the files together and then run the code on a server.\r\n\r\nInstall Parcel with\r\n```sh\r\nnpm install -D parcel@2.2.1\r\n```\r\n\r\nInside the `package.json` file, add the following script to `\"scripts\"`.\r\n```sh\r\n\"dev\": \"parcel src/index.html\",\r\n```\r\n\r\nThen we can use `npm run dev` to run the app. The app will be served on `localhost`. It will automatically watch for changes and rebuild the app.\r\n\r\n### Browserslist\r\n\r\nTransforms JS code from futuristic code to code that is understandable by older browsers with Babel.\r\n\r\nBrowserslist are intstalled with Parcel and can be used to specify the browsers that the code will be transpiled to. Add to `package.json`\r\n\r\n```json\r\n{\r\n    ...\r\n    \"browserslist\": [\r\n        \"last 2 Chrome versions\"\r\n    ]\r\n}\r\n```\r\n\r\n## Core React Concepts\r\n\r\n### JSX\r\n\r\nMakes code more readable and more HTML-like. React component in JSX should be written in capitalized format.\r\n\r\n```jsx\r\nconst Pet = (props) => {\r\n  return (\r\n    <div>\r\n      <h1>{props.name}</h1>\r\n      <h2>{props.animal}</h2>\r\n      <h2>{props.breed}</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Pet;\r\n```\r\n\r\nJavascript expression inside the return value is wrapped in `{}` e.g. `{props.name}`.\r\n\r\n### Hooks\r\n\r\nHooks get caught every time a component is rendered. We can keep pieces of mutable state and modify them later using the updater functions.\r\n\r\nTo add a hook \r\n\r\n**useState**\r\n\r\n`const [state, setState] = useState(initialState)`. \r\n\r\nState is the piece of mutable state and setState is the updater function. The updater function is used to update the state value.\r\n\r\n```jsx\r\nimport { useState } from \"react\";\r\n\r\nconst App = () => {\r\n    const [location, setLocation] = useState(\"\");\r\n    return (\r\n        <input\r\n            id=\"location\"\r\n            value={location}\r\n            placeholder=\"Location\"\r\n            onChange={(e) => setLocation(e.target.value)}\r\n        />\r\n    );\r\n}\r\n```\r\n\r\n**useEffect**\r\n\r\nAllows to say \"do a render of this component first so the user can see something then as soon as the render is done, then do something (the something here being an effect.)\". The effect is a function that is called when the component is rendered.\r\n\r\nTo let the user see the UI first before make request to API, we put the request API in the `useEffect` hook.\r\n\r\n```jsx\r\n// change import at top\r\nimport { useEffect } from \"react\";\r\n\r\nconst App () => {\r\n    useEffect(() => {\r\n      requestPets();\r\n    }, []); // dependent var. will call exactly once.\r\n    // if we want it to call every time breed changes, change [] to [breed]\r\n    // if no second argument, it will call everytime the component is rendered (anything changes).\r\n    \r\n    async function requestPets() {\r\n      const res = await fetch(\r\n        ...\r\n      );\r\n    }\r\n    \r\n    ...\r\n}\r\n```\r\n\r\n**Custom Hooks**\r\n\r\nWe can use one or several react hooks to make a reusable custom hooks.\r\n\r\n```jsx\r\nimport { useState, useEffect } from \"react\";\r\n\r\nexport default function useBreedList(animal) {\r\n  const [breedList, setBreedList] = useState([]);\r\n  const [status, setStatus] = useState(\"unloaded\");\r\n\r\n  useEffect(() => {\r\n    if (!animal) {\r\n      ...\r\n    }\r\n\r\n    async function requestBreedList() {\r\n      ...\r\n    }\r\n  }, [animal]);\r\n\r\n  return [breedList, status];\r\n}\r\n```\r\n\r\nThe function will return two things. We can use the hooks like this\r\n\r\n```jsx\r\nimport useBreedList from \"./useBreedList\";\r\n\r\nconst [breeds] = useBreedList(animal);\r\n```\r\n\r\n### Handling User Input\r\n\r\nTo listen to user actions on input like submit events\r\n\r\n```jsx\r\n<form\r\n  onSubmit={e => {\r\n    e.preventDefault();\r\n    requestPets();\r\n  }}\r\n>\r\n```\r\n\r\nThere are other listener like `onChange`, on mouse enter, key pres, copy paste, etc.\r\n\r\n### React Dev Tools\r\n\r\n**`NODE_ENV=development`**\r\n\r\nWhen using Parcel, there are some developer conveniences for debugging stuffs to help in development. When building the app, the environment variable will be `NODE_ENV=production` to strip the development tools and make the bundle smaller.\r\n\r\n**<React.StrictMode>**\r\n\r\nWill give additional warnings about things that might be wrong in React usage.\r\n\r\n**DevTools extension**\r\n\r\nExtension to explore DOM tree, modify state, props, etc.\r\n\r\n## React Capabilities\r\n\r\n### React Router\r\n\r\nInstall\r\n\r\n```sh\r\nnpm install react-router-dom@6.2.1\r\n```\r\n\r\nTo use\r\n\r\n```jsx\r\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\r\n\r\nconst App = () => {\r\n  return (\r\n    <BrowserRouter>\r\n      ...\r\n      <Routes>\r\n        <Route path=\"/details/:id\" element={<Details />} />\r\n        <Route path=\"/\" element={<SearchParams />} />\r\n      </Routes>\r\n    </BrowserRouter>\r\n  );\r\n}\r\n```\r\n\r\nTo make link to page, use `<Link>` so React won't totally reload the entire app all over again when clicked.\r\n\r\n```jsx\r\n<Link to={`/details/${id}`} className=\"pet\">\r\n  ...\r\n</Link>;\r\n```\r\n\r\nTo get the `id` params from the URL, use `useParams()`.\r\n\r\n```jsx\r\nimport { useParams } from \"react-router-dom\";\r\n\r\nconst Details = () => {\r\n  const { id } = useParams();\r\n  return (\r\n    ..\r\n  );\r\n}\r\n```\r\n\r\n### Class Components\r\n\r\nUse class as a way to declare a component.\r\n\r\n```jsx\r\nimport { Component } from \"react\";\r\n...\r\n\r\nclass Details extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      ...\r\n    };\r\n  }\r\n\r\n  async componentDidMount() {\r\n    ...\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        ...\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nClass elements:\r\n\r\n- Declaration: React class extends `React.Component` and have one render method that returns JSX.\r\n- `constructor()`: We can set the initial state. We have to write `super(props)` at the beginning so it also run the constructor of the parent class.\r\n- `componentDidMount()`: Called after the component is rendered. Usage example: to make a request to API.\r\n- `this.state`: Mutable state of component, use `this.setState` to modify\r\n- `this.props`: Come from parent component, immutable.\r\n\r\nIf working with hooks, we make wrapper component that uses the hook and pass the jsx returns to the wrapper component.\r\n\r\n```jsx\r\nclass Details extends Component {\r\n  ...\r\n  render() {\r\n    ...\r\n    return (\r\n      ...\r\n    );\r\n}\r\n\r\nconst WrappedDetails = () => {\r\n  const params = useParams();\r\n  return (\r\n    <Details params={params} />\r\n  );\r\n}\r\n```\r\n\r\n### Class Properties\r\n\r\nInstall a Babel plugin to use class properties to replace constructor.\r\n\r\n```sh\r\nnpm i -D @babel/plugin-proposal-class-properties@7.16.7\r\n```\r\n\r\nMake file `.babelrc`\r\n\r\n```json\r\n{\r\n  \"plugins\": [\"@babel/plugin-proposal-class-properties\"]\r\n}\r\n```\r\n\r\nThe constructor in class Details can be replaced to\r\n\r\n```jsx\r\nclass Details extends Component {\r\n  state = { loading: true };\r\n  ...\r\n}\r\n```\r\n\r\n### Managing State in Class Components\r\n\r\nWe can have defaultProps in class components to set props that a component has by default if it's not passed from the parent.\r\n\r\nMake event listener\r\n\r\n```jsx\r\nhandleIndexClick = event => {\r\n  this.setState({\r\n    ...\r\n  });\r\n}\r\n...\r\n<img \r\n  onClick={this.handleIndexClick} \r\n  ... \r\n/>\r\n```\r\n\r\n## Special Case React Tools\r\n\r\n### Error Boundaries\r\n\r\nTo catch errors in components.\r\n\r\n```jsx\r\nclass ErrorBoundary extends Component {\r\n  state = { hasError: false };\r\n  static getDerivedStateFromError() {\r\n    return { hasError: true };\r\n  }\r\n\r\n  componentDidCatch(error, info){\r\n    console.error(\"ErrorBoundary caught an error\", error, info);\r\n  }\r\n\r\n  render () {\r\n    if (this.state.hasError) {\r\n      return ...\r\n    }\r\n\r\n    return ...\r\n  }\r\n}\r\n...\r\n```\r\n\r\nNow wrap the component with `<ErrorBoundary>` and catch the error.\r\n```jsx\r\nconst WrappedDetails = () => {\r\n  ...\r\n  return (\r\n    <ErrorBoundary>\r\n      ...\r\n    </ErrorBoundary>\r\n  )\r\n}\r\n```\r\n\r\nTo make redirect automatically, use `componentDidUpdate`\r\n\r\n```jsx\r\nclass Details extends Component {\r\n  state = { hasError: false, redirect: false };\r\n  ...\r\n\r\n  componentDidUpdate() {\r\n    if (this.state.hasError) {\r\n      setTimeout(() => this.setState({ redirect: true }), 5000);\r\n    }\r\n  }\r\n\r\n  ...\r\n  \r\n  if (this.state.redirect) {\r\n    return <Navigate to=\"/\" />;\r\n  } } else if (this.state.hasError) {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n### Context\r\n\r\nContext is like global state in application. Mostly replaces Redux. Context won't really be used in most of applications, only use when needed.\r\n\r\n```jsx\r\nimport { createContext } from \"react\";\r\n\r\nconst ThemeContext = createContext([\"green\", () => {}]);\r\n\r\n...\r\n```\r\n\r\n`createContext` returns two object, `Provider` and `Consumer`. Provider is the component that provides the context and Consumer is the component that consumes the context. Consumer accept function as a child and give it to the context. To use the consumer, use `useContext`.\r\n\r\n```jsx\r\nimport ThemeContext from \"./ThemeContext\";\r\n\r\n// top of SearchParams function body\r\nconst [theme, setTheme] = useContext(ThemeContext);\r\n```\r\n\r\nTo consume inside class component\r\n\r\n```jsx\r\n// import\r\nimport ThemeContext from \"./ThemeContext\";\r\n\r\n// replace button\r\n<ThemeContext.Consumer>\r\n  {([theme]) => (\r\n    <button style={{ backgroundColor: theme }}>Adopt {name}</button>\r\n  )}\r\n</ThemeContext.Consumer>\r\n```\r\n\r\nTo change the theme in the context, use `setTheme`.\r\n\r\n\r\n### Portals and `useRef`\r\n\r\nSeparate mount point. Can be used to make a modal or contextual navbar.\r\n\r\n```jsx\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { createPortal } from \"react-dom\";\r\n\r\nconst Modal = ({ children }) => {\r\n  const elRef = useRef(null);\r\n  if (!elRef.current) {\r\n    elRef.current = document.createElement(\"div\");\r\n  }\r\n\r\n  useEffect(() => {\r\n    const modalRoot = document.getElementById(\"modal\");\r\n    modalRoot.appendChild(elRef.current);\r\n    return () => modalRoot.removeChild(elRef.current);\r\n  }, []);\r\n\r\n  return createPortal(<div>{children}</div>, elRef.current);\r\n}\r\n...\r\n```\r\n\r\nThis will mount the component when rendered and then remove it when unrendered.\r\n\r\nRefs are instance variable for function components. Anytime refer to `elRef.current`, it will always referring to the same element, while `useState` will always refer to the state of variable when the function is called."}},"__N_SSG":true}