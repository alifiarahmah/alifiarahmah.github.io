{"pageProps":{"post":{"title":"Testing React with Jest and React Testing Library (RTL)","date":"2020-08-12","slug":"testing-react-with-jest-and-react-testing-library-rtl","content":"\r\nThis is the note I take as I watch this course \r\n[Testing React with Jest and React Testing Library (RTL) - Udemy](https://www.udemy.com/course/react-testing-library/)\r\n\r\n## Introduction\r\n\r\nReact Testing Library (RTL) is a library that provides virtual DOM for React testing. Jest is a framework to run tests that is designed to be used in a CLI. In We write test using a testing function `test()` that takes two arguments: a description of the test and a callback function that contains the test code. \r\n\r\nThe testing processes are basically like using assertions. First we find the element on the app, then we can use assertions to check value of an element (`expect(...).toBe(...)`), and several other assertions are available. It throws error if the assertion fails.\r\n\r\nTesting library recommends finding elements in testing by using accesibility handles. There are several handles, especially `getByText()` (but better using `getByRole()`) and `getByTestId()`. This also encourages us to make the accesibility of the app is better.\r\n\r\n### Test-driven Development\r\n\r\nTest-driven development is a development method that creating test first before building the app. The code then will be implemented with specs from test file. The difference between TDD and BDD (Behavior-driven Development) is that TDD is focused on writing tests first, and BDD is focused on writing code first and involves a lot of people in different roles while the TDD is focused on writing tests first.\r\n\r\nType of tests:\r\n1. Unit tests: Test one small piece of functionality in isolation\r\n2. Integration tests: Test multiple units working together\r\n3. Functional tests: Test a functionality of how users interact in isolation (e.g. fill form and submit)\r\n4. Acceptance/End-to-end (E2E) tests: Test using actual browser and server\r\n\r\n## Examples\r\n\r\nGet button with text \"Change to blue\" and expect it to be red in initial\r\n\r\n```jsx\r\nconst colorButton = screen.getByRole('button', {name: 'Change to blue'});\r\nexpect(colorButton).toHaveStyle({ backgroundColor: 'red' });\r\n```\r\n\r\nExpect button to be red when clicked\r\n\r\n```jsx\r\nfireEvent.click(colorButton);\r\nexpect(colorButton).toHaveStyle({ backgroundColor: 'blue' });\r\n```\r\n\r\n### When to do unit test\r\nSome simple case could be covered by functional tests. But for complicated functions, unit test helps with:\r\n- Covering all possible edge cases\r\n- Determining what caused functional tests to fail\r\nIssue with functional test: High-level makes them resistant to refactors and makes them difficult to diagnose\r\n\r\n## ESLint and Prettier in Testing Library\r\n\r\nESLint: A popular linter for Javascripts. Linter is a tool that analyzes text and marks syntax that breaks rules. Linter analyzes code as written, not what happens when code is run. Linter also can adress format and style, for example, preferred assertion method.\r\n\r\nPrettier: A tool that formats code writing such as indents, spacing, and spaces around curly braces.\r\n\r\nESLint has plugin for testing library and Jest DOM.  Install it by\r\n\r\n```\r\nnpm install eslint-plugin-testing-library eslint-plugin-jest-dom\r\n```\r\n\r\nAt the root directory, create file `.eslintrc.json`.\r\n\r\n```json\r\n{\r\n\t\"plugins\": [\r\n\t\t\"testing-library\", \r\n\t\t\"jest-dom\"\r\n\t],\r\n\t\"extends\" [\r\n\t\t\"react-app\",\r\n\t\t\"react-app/jest\",\r\n\t\t\"plugin:testing-library/recommended\",\r\n\t\t\"plugin:testing-library/react\",\r\n\t\t\"plugin:jest-dom/recommended\"\r\n\t]\r\n}\r\n```\r\n\r\n### Configure ESLint in VSCode\r\n\r\nCreate new file in `.vscode/settings.json`\r\n\r\n```json\r\n{\r\n\t\"editor.codeActionsOnSave\": {\r\n\t\t\"source.fixAll.eslint\": true\r\n\t}\r\n}\r\n```\r\n\r\nAdd `.vscode` and `.eslintcache` to `.gitignore`.\r\n\r\nIf we working on VSCode, we can install ESLint plugin in VSCode. And then allow ESLint to run. If there's red underline mark on code, it means ESLint found error. If we check the error, we can see the error message and sometimes we can quick fix it.\r\n\r\n### Configure Prettier in VSCode\r\n\r\nIn `.vscode/settings.json` (or `settings.json`)\r\n\r\n```json\r\n{\r\n\t\"editor.defaultFormatter\": \"prettier\",\r\n\t\"editor.formatOnSave\": true\r\n}\r\n```\r\n\r\n## Screen Query Methods\r\n\r\nThe format is `command[All]ByQueryType`\r\n\r\n`command`:\r\n- `get`: expect element to be in DOM\r\n- `query`: expect element not to be in DOM\r\n- `find`: expect element to appar async\r\n\r\n`All`:\r\nExpect more than one match. If you want to expect only one match, exclude it.\r\n\r\n`ByQueryType`:\r\n- `ByRole`: expect element with role\r\n- `ByAltText`: expect element with alt text (for images)\r\n- `ByText`: expect element with text\r\n- Form elments:\r\n\t- `ByPlaceholderText`: expect element with placeholder text\r\n  - `ByLabelText`: expect element with label text\r\n\t- `ByDisplayValue`: expect element with display value\r\n\r\nMore references on screen query on the docs\r\n\r\n## Simulating Server Response with Mock Service Worker\r\n\r\nIn testing the network stuffs like fetching data from server, we need to simulate the server response. We can use mock service worker to simulate the server response.\r\n\r\n### Setup\r\n\r\n```\r\nnpm install msw\r\n```\r\n\r\nCreate file `mocks/handlers.js`.\r\n\r\n```js\r\nimport { rest } from 'msw';\r\n\r\nexport const handlers = [\r\n\trest.get(..., (req, res, ctx) => {\r\n\t\treturn res(ctx.json([\r\n\t\t\t{ ... },\r\n\t\t\t{ ... },\r\n\t\t\t{ ... },\r\n\t\t]));\r\n\t}),\r\n]\r\n```\r\n\r\nCreate file `mocks/server.js`\r\n\r\n```js\r\nimport { setupServer } from 'msw/node';\r\nimport { handlers } from './handlers';\r\n\r\nexport const server = setupServer(...handlers);\r\n```\r\n\r\n### Test with Mock Service Worker\r\n\r\n```jsx\r\nimport { render, screen } from '@testing-library/react';\r\n...\r\n\r\ntest(..., () => {\r\n\trender(<... />);\r\n\r\n\tconst scoopImages = screen.getAllByRole('img', { name: ... });\r\n\texpect(scoopImages).toHaveLength(2);\r\n\r\n\t// @ts-ignore\r\n\tconst altTexts = scoopImages.map((element) => element.alt);\r\n\texpect(altTexts).toEqual([..., ...]);\r\n})\r\n```\r\n\r\n### Simulating Server Error Response\r\n\r\n```jsx\r\nimport { render, screen } from '@testing-library/react';\r\nimport { rest } from 'msw';\r\nimport { server } from '.../mocks/server';\r\n\r\ntest('handles error', async () => {\r\n\tserver.resetHandlers(\r\n\t\trest.get('http://localhost:3030/scoops', (req, res, ctx) => {\r\n\t\t\treturn res(ctx.status(500));\r\n\t\t}),\r\n\t\trest.get('http://localhost:3030/toppings', (req, res, ctx) => {\r\n\t\t\treturn res(ctx.status(500));\r\n\t\t}),\r\n\t);\r\n\r\n\trender(<... />);\r\n\r\n\tconst alerts = await screen.findAllByRole('alert', { name: ... });\r\n\r\n\texpect(alerts).toHaveLength(2);\r\n});\r\n```\r\n\r\n## Testing Components Wrapped in a Provider\r\n\r\n```jsx\r\nimport { render, screen } from '@testing-library/react';\r\n...\r\n\r\ntest(... async () => {\r\n\trender(<... />);\r\n\r\n\tconst scoopSubtotal = ...;\r\n\texpect(scoopSubtotal).toHaveTextContent(...);\r\n\r\n\tconst vanillaInput = await screen.findByRole(..., { name: ... });\r\n\tawait userEvent.clear(vanillaInput); // clear first\r\n\tawait userEvent.type(vanillaInput, ...);\r\n\texpect(scoopSubtotal).toHaveTextContent(...);\r\n})\r\n```\r\n\r\nWrap isolated component in a provider\r\n\r\n```jsx\r\n...\r\nimport { ... } from '.../contexts/...'\r\n\r\ntest(..., async () => {\r\n\trender(<... />, { wrapper: ... });\r\n})\r\n```\r\n\r\n### Create custom render to wrap in provider by default\r\n\r\nWe can do this by creating test utilities and change the import statement to use the test utilities we made.\r\n\r\nCreate file `test-utils/testing-library-utils.jsx`\r\n\r\n```jsx\r\nimport { render } from '@testing-library/react';\r\nimport { CustomProvider } from ...;\r\n\r\nconst renderWithContext = (ui, options) => {\r\n\treturn render(ui, { wrapper: CustomProvider, ...options });\r\n}\r\n\r\nexport * from '@testing-library/react';\r\n\r\nexport { renderWithContext as render };\r\n```\r\n\r\nIn test file that needs custom render, change all render and screen imports.\r\n\r\n```jsx\r\nimport { render, screen } from '.../test-utils/testing-library-utils';\r\n...\r\n\r\ntest(..., async () => {\r\n\trender(<... />);\r\n\t...\r\n}\r\n```\r\n\r\n"}},"__N_SSG":true}